{"meta":{"title":"我的主页","subtitle":null,"description":null,"author":"梦里不知身是客","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"魔术方法总结","slug":"魔术方法总结","date":"2017-02-11T06:19:33.000Z","updated":"2017-02-11T08:35:26.465Z","comments":true,"path":"2017/02/11/魔术方法总结/","link":"","permalink":"http://yoursite.com/2017/02/11/魔术方法总结/","excerpt":"","text":"construct()，类的构造函数 destruct()，类的析构函数call()，在对象中调用一个不可访问方法时调用 callStatic()，用静态方式中调用一个不可访问方法时调用get()，获得一个类的成员变量时调用 set()，设置一个类的成员变量时调用isset()，当对不可访问属性调用isset()或empty()时调用 unset()，当对不可访问属性调用unset()时被调用。sleep()，执行serialize()时，先会调用这个函数 wakeup()，执行unserialize()时，先会调用这个函数toString()，类被当成字符串时的回应方法 invoke()，调用函数的方式调用一个对象时的回应方法set_state()，调用var_export()导出类时，此静态方法会被调用。 clone()，当对象复制完成时调用autoload()，尝试加载未定义的类 debugInfo()，打印所需调试信息","categories":[],"tags":[]},{"title":"冒泡排序法","slug":"冒泡排序法","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:57:49.277Z","comments":true,"path":"2016/02/11/冒泡排序法/","link":"","permalink":"http://yoursite.com/2016/02/11/冒泡排序法/","excerpt":"","text":"冒泡排序法 123456789101112131415161718192021function bubbleSort($numbers) &#123; $cnt = count($numbers); for ($i = 0; $i &lt; $cnt; $i++) &#123; for ($j = 0; $j &lt; $cnt - $i - 1; $j++) &#123; if ($numbers[$j] &gt; $numbers[$j + 1]) &#123; $temp = $numbers[$j]; $numbers[$j] = $numbers[$j + 1]; $numbers[$j + 1] = $temp; &#125; &#125; &#125; return $numbers;&#125; $num = array(20, 40, 60, 80, 30, 70, 90, 10, 50, 0);var_dump(bubbleSort($num));","categories":[],"tags":[]},{"title":"快速排序法","slug":"快速排序法","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:53:19.987Z","comments":true,"path":"2016/02/11/快速排序法/","link":"","permalink":"http://yoursite.com/2016/02/11/快速排序法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536//快速排序//待排序数组$arr=array(6,3,8,6,4,2,9,5,1);//函数实现快速排序function quick_sort($arr)&#123; //判断参数是否是一个数组 if(!is_array($arr)) return false; //递归出口:数组长度为1，直接返回数组 $length=count($arr); if($length&lt;=1) return $arr; //数组元素有多个,则定义两个空数组 $left=$right=array(); //使用for循环进行遍历，把第一个元素当做比较的对象 for($i=1;$i&lt;$length;$i++) &#123; //判断当前元素的大小 if($arr[$i]&lt;$arr[0]) &#123; $left[]=$arr[$i]; &#125; else &#123; $right[]=$arr[$i]; &#125; &#125; //递归调用 $left=quick_sort($left); $right=quick_sort($right); //将所有的结果合并 return array_merge($left,array($arr[0]),$right);&#125;//调用echo &quot;&lt;pre&gt;&quot;;print_r(quick_sort($arr));","categories":[],"tags":[]},{"title":"分苹果","slug":"1000个苹果分成10堆","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:32:46.185Z","comments":true,"path":"2016/02/11/1000个苹果分成10堆/","link":"","permalink":"http://yoursite.com/2016/02/11/1000个苹果分成10堆/","excerpt":"","text":"问题：1000个苹果分成10堆，可以组合任意1-1000个数的苹果此问题是否有解？如何求解？1.首先我们必须写一个验证的程序123456789101112131415161718192021222324252627 /** * 验证数组 * @author syh * @param array $arr * @return bool */ function check($arr) &#123; rsort($arr);//逆序 $listNum=range(1,array_sum($arr)); $fun=function ($num) use ($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; if($num===$val) return true; //减去数组中比自己小的最大值 if($num&gt;$val) $num=$num-$val; &#125; return false; &#125;; return !in_array(false,array_map($fun,$listNum)); &#125;$arr=[1,2,4,8,16,32,64,128,256,489];//此数组为正解的一种，可以通过验证$data=check($arr);var_dump($data);//true 2.遍历所有可能的组合或随机取值2.0非递归遍历（最原始的实现） 1234567891011121314151617181920212223242526272829303132333435363738394041/** * $m个苹果分为4堆 * @author syh * @param int $m苹果总数 * @return array 验证通过后的数组 */ function test($m) &#123; $listAll=[]; $list=[]; $len=4;//苹果堆数 $max=function($list) use ($m,$len)&#123; return $m-array_sum($list)-($len-count($list))+1; &#125;; for ($k1=1,$max1=$max($list);$k1 &lt;=$max1; $k1++) &#123; $list[1]=$k1; for ($k2=1,$max2=$max($list);$k2 &lt;=$max2 ;$k2++) &#123; $list[2]=$k2; for ($k3=1,$max3=$max($list);$k3 &lt;=$max3; $k3++) &#123; $list[3]=$k3; $list[4]=$m-array_sum($list); if(check($list)) &#123; $listAll[]=$list; &#125; unset($list[3]); unset($list[4]); &#125; unset($list[2]); &#125; unset($list[1]); &#125; return $listAll; &#125; 2.1第一种遍历所有可能， 123456789101112131415161718192021222324252627282930313233343536373839/*** 递归实现1* @author int $m 苹果的个数* @param int $n 苹果堆数* @return array*/function crateArr($m,$n)&#123; static $list=[];//保存当前的组合 static $listAll=[];//保存所有可能的组合 static $count=0,$len; if(($count++)===0) $len=$n;//保存数组长度 $max=$m-array_sum($list)-($len-count($list))+1; for ($i=1;$i&lt;=$max;$i++) &#123; $list[$n]=$i;//第$n堆苹果 if ($n===2) &#123; //此处为最后一次循环 $list[$n-1]=$m-array_sum($list);//最后一堆苹果的个数 if (check($list)) &#123; $listAll[]=$list; //验证通过后合并 &#125; unset($list[$n-1]); unset($list[$n]); &#125; elseif($n&gt;2) &#123; crateArr($m,$n-1);//递归进行 相当于for循环嵌套 unset($list[$n]); &#125; &#125; return $listAll;//返回所有符合要求的组合 &#125; 2.2第一种遍历的次数太多，进一步优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** *递归实现2 * @author syh * @param string $m 苹果总数 * @param string $n 苹果堆数 * @param string $p 第一堆苹果起始值 * @return array */function createArr($m,$n,$p=1)&#123; static $list=[],$listAll=[]; static $count=0,$len; if(($count++)===0) $len=$n;//保存数组长度 $d=$len-($len-$n)-1;//第$n项到$len-1项的元素个数 // 假设第$n堆苹果到$len-1堆苹果数位公差为1的等差数列 //最后一堆苹果个数=苹果总和-当前堆前面的总和-当前堆到第$len-1堆等差数列的和 //第$len-1堆苹果的个数为a1+(n-1)*d 等差数列第n项公式 //当前堆到$len-1的总和为a1*n+n*(n-1)*d/2等差数列前n项和 // 数组为从小到大排序，当最后一项与倒数第二项相等时为每堆苹果的最大值，即临界点 $max=($m-array_sum($list)-$d*($d-1)/2-$len+1)/($d+1)+1; for ($i=$p;$i&lt;=ceil($max);$i++) &#123; $list[$n]=$i; if ($n===2) &#123; $list[$n-1]=$m-array_sum($list); if(check($list)) &#123; // 验证通过后存入数组 $listAll[]=$list; &#125; unset($list[$n-1]); unset($list[$n]); &#125; elseif($n&gt;2) &#123; $function=__FUNCTION__; //堆数递减，后面堆苹果最小个数=前面堆苹果个数+1 $function($m,$n-1,$i+1); unset($list[$n]); &#125; &#125; return $listAll; &#125; 2.3随机取值 12345678910111213function crateArr($sum,$len) &#123; while(1) &#123; $arr=[]; for ($j=1; $j&lt;=$len; $j++) &#123; $max=$sum-array_sum($arr)-($len-count($arr))+1; $arr[$j]=($j==$len)?$sum-array_sum($arr):mt_rand(1,$max); &#125; if(check($arr)) var_dump($arr); &#125; &#125; 总结：经过自己不懈的努力，程序终于实现了；但1000个苹果分成10堆计算量太大，自己的电脑最多能计算300个苹果分成10堆。1,2,4,8,16,32,64,128,256,489通过观察得出，符合此规律的等比数列，能组合的最大数为2的（数列长度）次方-1。通过程序验证63（2^6-1）个苹果分成6堆苹果只有一个解，小于63就会存在多解；同理，1000个苹果分成10堆，能组合的最大数为2^10-1（1023）;所以此问题存在多解，上面的数列只是其中一种解。2.4 进一步研究，求全部解 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 遍历后2位* 此解并不是最终解* @author syh* @return array*/function checkAll()&#123; $arr=[1,2,4,8,16,32,64,128,256,489]; $list=[]; for ($i=256; $i &gt;128 ; $i--) &#123; array_pop($arr); array_pop($arr); array_push($arr, $i,745-$i); if (check($arr)) &#123; $list[]=implode(&apos;--&apos;,$arr); &#125; &#125; return $list;&#125; $data=checkAll($arr); echo &apos;&lt;pre&gt;&apos;; print_r($data); Array( [0] =&gt; 1--2--4--8--16--32--64--128--256--489 [1] =&gt; 1--2--4--8--16--32--64--128--255--490 [2] =&gt; 1--2--4--8--16--32--64--128--254--491 [3] =&gt; 1--2--4--8--16--32--64--128--253--492 [4] =&gt; 1--2--4--8--16--32--64--128--252--493 [5] =&gt; 1--2--4--8--16--32--64--128--251--494 [6] =&gt; 1--2--4--8--16--32--64--128--250--495 [7] =&gt; 1--2--4--8--16--32--64--128--249--496 [8] =&gt; 1--2--4--8--16--32--64--128--248--497 [9] =&gt; 1--2--4--8--16--32--64--128--247--498 [10] =&gt; 1--2--4--8--16--32--64--128--246--499 [11] =&gt; 1--2--4--8--16--32--64--128--245--500) 遍历后3位有42种解,遍历后4位电脑又罢工了","categories":[],"tags":[]}]}